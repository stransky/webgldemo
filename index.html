<!DOCTYPE HTML>
<html>
<head>
<title>WebGL Demo</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="vertex-vs" type="x-shader/x-vertex">
  /* OpenGL ES's shading language - Vertex shader
  */
  /* Mohu si volne definovat promene, ktere plnim daty (vertexy/barvy/textury...)
  
     Typy:
       attribute - plnene "zvenku" - vetsinou z pole
       uniform   - konstanty
       varying   - "generovane" promene - automaticky se interpoluji mezi 
                   vertexy
                   
     Jmeno promene nesmi zacinat na gl_ - tyto promene jsou vyhrazene
     pro WebGL a maji specialni vyznam, napr:
     
     gl_Position   - vysledna poloha vertexu (2D (x,y) + "hloubka" pro Z-buffer (Z) + vaha (W))
  */
  
  // Me promene s pozici vertextu a koordinatama textur
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;
  
  // Me matice (View a Projection)
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  
  // varying - prenasi se do pixel shaderu interpolaci mezi vertexy
  varying vec2 vTextureCoord;
      
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }
</script>

<script id="pixel-ps" type="x-shader/x-fragment">
  /* OpenGL ES's shading language - Pixel (Fragment) shader
  */
  precision mediump float;
  
  // varying - interpolovana hodnota z vertex shaderu
  varying vec2 vTextureCoord;
  
  // konstanta - zde pro pouzitou texturu
  uniform sampler2D uTexture;
  
  void main(void) {
      gl_FragColor = texture2D(uTexture, vec2(vTextureCoord.s, vTextureCoord.t));
  }
</script>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="textures.js"></script>
<script type="text/javascript" src="helpers.js"></script>
<script type="text/javascript" src="logic.js"></script>
<script type="text/javascript" src="objects.js"></script>
<script type="text/javascript" src="loaders.js"></script>
<script type="text/javascript" src="graphics.js"></script>
<script type="text/javascript" src="controls.js"></script>
<script type="text/javascript" src="camera.js"></script>

<script>
  var cubeVertexPositionBuffer;
  var cubeVertexTextureCoordBuffer;
  var cubeVertexIndexBuffer;
  function initBuffers() {
      cubeVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      vertices = [
          // Front face
          -1.0, -1.0,  1.0,
           1.0, -1.0,  1.0,
           1.0,  1.0,  1.0,
          -1.0,  1.0,  1.0,

          // Back face
          -1.0, -1.0, -1.0,
          -1.0,  1.0, -1.0,
           1.0,  1.0, -1.0,
           1.0, -1.0, -1.0,

          // Top face
          -1.0,  1.0, -1.0,
          -1.0,  1.0,  1.0,
           1.0,  1.0,  1.0,
           1.0,  1.0, -1.0,

          // Bottom face
          -1.0, -1.0, -1.0,
           1.0, -1.0, -1.0,
           1.0, -1.0,  1.0,
          -1.0, -1.0,  1.0,

          // Right face
           1.0, -1.0, -1.0,
           1.0,  1.0, -1.0,
           1.0,  1.0,  1.0,
           1.0, -1.0,  1.0,

          // Left face
          -1.0, -1.0, -1.0,
          -1.0, -1.0,  1.0,
          -1.0,  1.0,  1.0,
          -1.0,  1.0, -1.0,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      cubeVertexPositionBuffer.itemSize = 3;
      cubeVertexPositionBuffer.numItems = 24;

      cubeVertexTextureCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
      var textureCoords = [
          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,

          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,

          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,

          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
      cubeVertexTextureCoordBuffer.itemSize = 2;
      cubeVertexTextureCoordBuffer.numItems = 24;

      cubeVertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      var cubeVertexIndices = [
          0, 1, 2,      0, 2, 3,    // Front face
          4, 5, 6,      4, 6, 7,    // Back face
          8, 9, 10,     8, 10, 11,  // Top face
          12, 13, 14,   12, 14, 15, // Bottom face
          16, 17, 18,   16, 18, 19, // Right face
          20, 21, 22,   20, 22, 23  // Left face
      ]
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
      cubeVertexIndexBuffer.itemSize = 1;
      cubeVertexIndexBuffer.numItems = 36;
  }

  // Spocita vyslednou modelView matici (World*camera_inver
  function modelViewMatrixSet() {
    mat4.multiply(graph.worldMatrix, graph.cameraMatrix, graph.modelViewMatrix);
  }  

  // Nastavi tranformacni matice pro shader
  function setMatrixUniforms() {
    gl.uniformMatrix4fv(graph.shaderProgram.pMatrixUniform, false, graph.projectionMatrix);
    gl.uniformMatrix4fv(graph.shaderProgram.mvMatrixUniform, false, graph.modelViewMatrix);
  }
  
  function drawObject() {
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    gl.vertexAttribPointer(graph.shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    gl.vertexAttribPointer(graph.shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, globalTextures[0]);
    gl.uniform1i(graph.shaderProgram.samplerUniform, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    
    if(control.keys[KeyEvent.DOM_VK_UP]) {
      mat4.translate(graph.worldMatrix, [0,1,0]);
    }
    if(control.keys[KeyEvent.DOM_VK_DOWN]) {
      mat4.translate(graph.worldMatrix, [0,-1,0]);
    }
    if(control.keys[KeyEvent.DOM_VK_RIGHT]) {
      mat4.translate(graph.worldMatrix, [1,0,0]);
    }
    if(control.keys[KeyEvent.DOM_VK_LEFT]) {
      mat4.translate(graph.worldMatrix, [-1,0,0]);
    }
    
    modelViewMatrixSet();
    setMatrixUniforms();
    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
  }
  
  function drawScene() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if(graph.camera.changed) {
      graph.cameraMatrix = cameraSet(graph.camera.position, 
                                     graph.camera.rotation,
                                     graph.camera.elevation,
                                     graph.camera.distance);
      graph.camera.changed = 0;
    }

    drawObject();
  }
    
  // Kresli scenu (hlavni smycka)
  function animationFrame() {
    // zaregistruj animationFrame pro dalsi frame
    requestAnimFrame(animationFrame);

    // dopocitej zmeny mysi
    calcMouse();

    // 
    handleCamera();

    // Kresli scenu & spol.
    drawScene();    
  }

  // Start!
  function DemoStart() {
    graphicsInit();
    inputInit();

    initBuffers();
        
    loadTexture("test.jpg", 0);
    loadScene("test_level.json");

    animationFrame();
  }

</script>

<body onload="DemoStart();">
    <canvas id="webgl-canvas" onmousewheel="handleWheel();" width="800" height="600">
    </canvas>
</body>
</html>
