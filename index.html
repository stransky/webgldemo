<!DOCTYPE HTML>
<html>
<head>
<title>WebGL Demo</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="vertex-vs" type="x-shader/x-vertex">
  /* OpenGL ES's shading language - Vertex shader
  */
  /* Mohu si volne definovat promene, ktere plnim daty (vertexy/barvy/textury...)
  
     Typy:
       attribute - plnene "zvenku" - vetsinou z pole
       uniform   - konstanty
       varying   - "generovane" promene - automaticky se interpoluji mezi 
                   vertexy
                   
     Jmeno promene nesmi zacinat na gl_ - tyto promene jsou vyhrazene
     pro WebGL a maji specialni vyznam, napr:
     
     gl_Position   - vysledna poloha vertexu (2D (x,y) + "hloubka" pro Z-buffer (Z) + vaha (W))
  */
  
  // Me promene s pozici vertextu a koordinatama textur
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;
  
  // Me matice (View a Projection)
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  
  // varying - prenasi se do pixel shaderu interpolaci mezi vertexy
  varying vec2 vTextureCoord;
      
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }
</script>

<script id="pixel-ps" type="x-shader/x-fragment">
  /* OpenGL ES's shading language - Pixel (Fragment) shader
  */
  precision mediump float;
  
  // varying - interpolovana hodnota z vertex shaderu
  varying vec2 vTextureCoord;
  
  // konstanta - zde pro pouzitou texturu
  uniform sampler2D uTexture;
  
  void main(void) {
      gl_FragColor = texture2D(uTexture, vec2(vTextureCoord.s, vTextureCoord.t));
  }
</script>

<script>
  // Globalni WebGL objekt
  var gl;
  
  // Globalni objekt pro graficke data
  var graph = new Object();

  // Moje WebGL matice
  graph.worldMatrix = mat4.create();
  mat4.identity(graph.worldMatrix);  
  graph.cameraMatrix = mat4.create();  
  
  // Vysledne transformacni matice pro WebGL
  graph.modelViewMatrix = mat4.create();  
  graph.projectionMatrix = mat4.create();
  
  // Konfigurace polarnich souradnic kamery
  graph.camera = new Object();
  graph.camera.position = [0.0, 0.0, 0.0];
  graph.camera.rotation = 0.0;
  graph.camera.elevation = Math.PI/3; // 45 stupnu
  graph.camera.distance = -10.0;
  graph.camera.changed = 1;

  // Muj globalni objekt se vsupem z klavesnice/mysi
  const button_first = 0;
  const button_middle = 1;
  const button_second = 2;
  const button_wheel_up = 4;
  const button_wheel_down = 5;
  
  var control = new Object();
  control.keys = {}; // pole stisknutych klaves
  control.mouse = new Object(); // Stav mysi
  control.mouse.mx = 0;
  control.mouse.my = 0;
  control.mouse.last_mx = 0;
  control.mouse.last_my = 0;
  control.mouse.buttons = {};  
  

  /* Zkompiluje DOM element script s programem shaderu 
     a vrati jako shader objekt WebGLShader
  */
  function getShader(gl, id) {
      var shaderScript = document.getElementById(id);
      if (!shaderScript) {
          return null;
      }

      /* Sestavi program shaderu z DOM elementu script do jednoho retezce
      */
      var str = "";
      var k = shaderScript.firstChild;
      while (k) {
          if (k.nodeType == 3) {
              str += k.textContent;
          }
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment") {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
      } else if (shaderScript.type == "x-shader/x-vertex") {
          shader = gl.createShader(gl.VERTEX_SHADER);
      } else {
          return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(shader));
          return null;
      }

      return shader;
  }

  /* Vytvori WebGLProgram objekt (potrebuje jak vertex tak pixel shader)
  */ 
  function createWebGLProgram() {
      var fragmentShader = getShader(gl, "pixel-ps");
      var vertexShader = getShader(gl, "vertex-vs");

      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          alert("Could not initialise shaders");
      }      

      gl.useProgram(program);
      
      // Vraci index promene aVertexPosition (soucast naseho vertex shaderu)
      program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
      // Nastavime aVertexPosition ke spracovani jako pole
      gl.enableVertexAttribArray(program.vertexPositionAttribute);

      // Podobne pro aTextureCoord - nastavime jako pole "vertexu"
      program.textureCoordAttribute = gl.getAttribLocation(program, "aTextureCoord");
      gl.enableVertexAttribArray(program.textureCoordAttribute);

      // Nacti indexy pro matice
      program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
      program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
      
      // Nacti index me promene s texturou
      program.samplerUniform = gl.getUniformLocation(program, "uTexture");
      
      return program;
  }

  function graphicsInit() {  
      var canvas = document.getElementById("webgl-canvas");
      try {
        gl = canvas.getContext("experimental-webgl");              
      } catch (e) {}      
      if (!gl) {
        alert("Sorry kamo, ale chce to jinej prohlizec!");
      }
      
      // Zakladni WebGL konfigurace
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      
      // Nastav projekcni matici
      gl.viewport(0, 0, canvas.width, canvas.height);
      mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, graph.projectionMatrix);
      
      // Zkompiluj shader program
      graph.shaderProgram = createWebGLProgram();  
  }

  function handleLoadedTexture(textures) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.bindTexture(gl.TEXTURE_2D, textures[0]);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[0].image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

      gl.bindTexture(gl.TEXTURE_2D, textures[1]);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[1].image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

      gl.bindTexture(gl.TEXTURE_2D, textures[2]);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures[2].image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.bindTexture(gl.TEXTURE_2D, null);
  }

  var crateTextures = Array();

  function initTexture() {  
      var crateImage = new Image();

      for (var i=0; i < 3; i++) {
          var texture = gl.createTexture();
          texture.image = crateImage;
          crateTextures.push(texture);
      }

      crateImage.onload = function () {
          handleLoadedTexture(crateTextures)
      }
      crateImage.src = "test.jpg";
  }
    

  var cubeVertexPositionBuffer;
  var cubeVertexTextureCoordBuffer;
  var cubeVertexIndexBuffer;
  function initBuffers() {
      cubeVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
      vertices = [
          // Front face
          -1.0, -1.0,  1.0,
           1.0, -1.0,  1.0,
           1.0,  1.0,  1.0,
          -1.0,  1.0,  1.0,

          // Back face
          -1.0, -1.0, -1.0,
          -1.0,  1.0, -1.0,
           1.0,  1.0, -1.0,
           1.0, -1.0, -1.0,

          // Top face
          -1.0,  1.0, -1.0,
          -1.0,  1.0,  1.0,
           1.0,  1.0,  1.0,
           1.0,  1.0, -1.0,

          // Bottom face
          -1.0, -1.0, -1.0,
           1.0, -1.0, -1.0,
           1.0, -1.0,  1.0,
          -1.0, -1.0,  1.0,

          // Right face
           1.0, -1.0, -1.0,
           1.0,  1.0, -1.0,
           1.0,  1.0,  1.0,
           1.0, -1.0,  1.0,

          // Left face
          -1.0, -1.0, -1.0,
          -1.0, -1.0,  1.0,
          -1.0,  1.0,  1.0,
          -1.0,  1.0, -1.0,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      cubeVertexPositionBuffer.itemSize = 3;
      cubeVertexPositionBuffer.numItems = 24;

      cubeVertexTextureCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
      var textureCoords = [
          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,

          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,

          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,

          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
      cubeVertexTextureCoordBuffer.itemSize = 2;
      cubeVertexTextureCoordBuffer.numItems = 24;

      cubeVertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
      var cubeVertexIndices = [
          0, 1, 2,      0, 2, 3,    // Front face
          4, 5, 6,      4, 6, 7,    // Back face
          8, 9, 10,     8, 10, 11,  // Top face
          12, 13, 14,   12, 14, 15, // Bottom face
          16, 17, 18,   16, 18, 19, // Right face
          20, 21, 22,   20, 22, 23  // Left face
      ]
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
      cubeVertexIndexBuffer.itemSize = 1;
      cubeVertexIndexBuffer.numItems = 36;
  }

  // Sestavi matici kamery z polarnich souradnic
  function cameraSet(position, rotation, elevation, distance) {
    var camera = mat4.create();
    
    mat4.identity(camera);
    mat4.translate(camera, position);
    mat4.rotateY(camera, rotation);
    mat4.rotateX(camera, elevation);
    mat4.translate(camera, [0.0, 0.0, -distance]);
  
    return mat4.inverse(camera);
  }

  // Spocita vyslednou modelView matici (World*camera_inver
  function modelViewMatrixSet() {
    mat4.multiply(graph.worldMatrix, graph.cameraMatrix, graph.modelViewMatrix);
  }  

  // Nastavi tranformacni matice pro shader
  function setMatrixUniforms() {
    gl.uniformMatrix4fv(graph.shaderProgram.pMatrixUniform, false, graph.projectionMatrix);
    gl.uniformMatrix4fv(graph.shaderProgram.mvMatrixUniform, false, graph.modelViewMatrix);
  }
  
  function drawObject() {
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    gl.vertexAttribPointer(graph.shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    gl.vertexAttribPointer(graph.shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, crateTextures[0]);
    gl.uniform1i(graph.shaderProgram.samplerUniform, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
              
    mat4.translate(graph.worldMatrix, [0,0,0]);
    
    modelViewMatrixSet();
    setMatrixUniforms();
    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
  }
  
  function drawScene() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if(graph.camera.changed) {
      graph.cameraMatrix = cameraSet(graph.camera.position, 
                                     graph.camera.rotation,
                                     graph.camera.elevation,
                                     graph.camera.distance);
      graph.camera.changed = 0;
    }

    drawObject();
  }
  
  function handleCamera() {
    // rotuj kameru
    if(control.keys[KeyEvent.DOM_VK_CONTROL]) {        
      graph.camera.rotation += Math.PI*0.002*control.mouse.dx;
      graph.camera.elevation -= Math.PI*0.002*control.mouse.dy;
      if(graph.camera.elevation < 0)
        graph.camera.elevation = 0;
      if(graph.camera.elevation > Math.PI/2)
        graph.camera.elevation = Math.PI/2;
      graph.camera.changed = 1;
    }
    
    // posun kameru
    if(control.keys[KeyEvent.DOM_VK_SHIFT]) {
      
    }
    
    // zoomuj kameru
  }
  
  function calcMouse() {
    control.mouse.dx = control.mouse.mx - control.mouse.last_mx;
    control.mouse.dy = control.mouse.my - control.mouse.last_my;
    
    dump("\n*******************************************\n");
    
    dump("control.mouse.mx = " + control.mouse.mx + "\n");
    dump("control.mouse.my = " + control.mouse.my + "\n");
    
    dump("control.mouse.last_mx = " + control.mouse.last_mx + "\n");
    dump("control.mouse.last_my = " + control.mouse.last_my + "\n");
    
    dump("control.mouse.dx = " + control.mouse.dx + "\n");
    dump("control.mouse.dy = " + control.mouse.dy + "\n");
    
    control.mouse.last_mx = control.mouse.mx;
    control.mouse.last_my = control.mouse.my;
  }

  function saveMouse() {
    control.mouse.last_buttons = control.mouse.buttons;
  }

  // Kresli scenu (hlavni smycka)
  function animationFrame() {
    // zaregistruj animationFrame pro dalsi frame
    requestAnimFrame(animationFrame);

    // dopocitej zmeny mysi
    calcMouse();

    // 
    handleCamera();

    // Kresli scenu & spol.
    drawScene();    
  }

  // Klavesy jsou definovane jako KeyEvent.DOM_VK_* konstanty
  function handleKeyDown(event) {
    control.keys[event.keyCode] = true;
  }
  function handleKeyUp(event) {
    control.keys[event.keyCode] = false;
  }

  // Vstup udalosti z mysi
  // Dokumentace k event je na:
  // https://developer.mozilla.org/en-US/docs/DOM/MouseEvent
  // event.screenX, event.screenY - globalni souradnice
  // event.clientX, event.clientY - lokalni souradnice (canvas)
  // event.button  - Left button=0, middle button=1, right button=2.
  // event.buttons - Left button=0, middle button=1 (if present), right button=2.
  //                 Middle (wheel) button=4,5
  function handleMouse(event) {    
    control.mouse.mx = event.clientX;
    control.mouse.my = event.clientY;
    //control.mouse.buttons[event.buttons];
  }

  function inputInit() {
    var canvas = document.getElementById("webgl-canvas");
    
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;    
    
    canvas.onmousedown = handleMouse;
    document.onmouseup = handleMouse;
    document.onmousemove = handleMouse;
  }

  // Start!
  function DemoStart() {
    graphicsInit();
    inputInit();

    initBuffers();
    initTexture();

    animationFrame();
  }

</script>

<body onload="DemoStart();">
    <canvas id="webgl-canvas" onmousewheel="handleWheel();" width="800" height="600">
    </canvas>
</body>
</html>
